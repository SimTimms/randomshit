/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from 'react';
import { useGLTF } from '@react-three/drei';
import Mesh from '../Mesh';
import edging from '../Base/edging.png';

export default function Model({ props }) {
  const group = useRef();
  const { nodes } = useGLTF(`${props.gltfIn}`);
  if (!nodes) {
    return 'Loading';
  }

  const rNbr = (number) => {
    return parseFloat(number.toFixed(Math.round(2)));
  };

  const rDeg = (number) => {
    const abs = Math.abs(Math.round(parseFloat(number) * 100000));
    for (let i = 1; i <= 10; i++) {
      if (abs === Math.round(parseFloat(Math.PI / i) * 100000))
        return Math.PI / 2;
    }
    return rNbr(number);
  };
  function node(nodeArr) {
    let nodeMap = [];
    if (nodeArr) {
      nodeMap = nodeArr.map((item) => {
        let scale = null;
        if (
          item.scale &&
          item.scale.isVector3 &&
          !(
            rNbr(item.scale.x) === 1 &&
            rNbr(item.scale.y) === 1 &&
            rNbr(item.scale.z) === 1
          )
        ) {
          if (item.scale.x === item.scale.y && item.scale.x === item.scale.z) {
            scale = rNbr(item.scale.x);
          } else {
            scale = [
              rNbr(item.scale.x),
              rNbr(item.scale.y),
              rNbr(item.scale.z),
            ];
          }
        }

        const nodeChildArr = Object.values(item.children);
        return item.geometry ? (
          <Mesh
            activeColor={props.activeColor}
            paintMode={props.paintMode}
            modelColors={props.modelColors}
            modelColorsRef={props.modelColorsRef}
            name={item.name}
            lightOne={props.lightOne}
            geometry={item.geometry}
            scale={item.scale}
            position={[
              rNbr(item.position.x),
              rNbr(item.position.y),
              rNbr(item.position.z),
            ]}
            rotation={[
              rDeg(item.rotation.x),
              rDeg(item.rotation.y),
              rDeg(item.rotation.z),
            ]}
          >
            {node(nodeChildArr, nodes)}
          </Mesh>
        ) : item.type === 'Object3D' ? (
          <group
            position={[
              rNbr(item.position.x),
              rNbr(item.position.y),
              rNbr(item.position.z),
            ]}
            scale={item.scale}
            rotation={[
              rDeg(item.rotation.x),
              rDeg(item.rotation.y),
              rDeg(item.rotation.z),
            ]}
          >
            {node(nodeChildArr, nodes)}
          </group>
        ) : null;
      });
    }
    return nodeMap.filter((item) => item !== null);
  }
  const nodeArr = Object.values(nodes);
  return (
    <group ref={group} {...props} dispose={null}>
      {node(nodeArr, nodes)}
    </group>
  );
  return (
    <group ref={group} {...props} dispose={null}>
      <Mesh
        activeColor={props.activeColor}
        paintMode={props.paintMode}
        modelColors={props.modelColors}
        modelColorsRef={props.modelColorsRef}
        name="Cylinder"
        lightOne={props.lightOne}
        geometry={nodes.Cylinder.geometry}
        scale={[4.05, -0.34, 4.05]}
        texture={edging}
      />
      <Mesh
        activeColor={props.activeColor}
        paintMode={props.paintMode}
        modelColors={props.modelColors}
        modelColorsRef={props.modelColorsRef}
        name="Cylinder001"
        lightOne={props.lightOne}
        geometry={nodes.Cylinder001.geometry}
        position={[0, 0.37, 0]}
        scale={[3.73, -0.05, 3.73]}
        texture={edging}
      />
    </group>
  );
}
